#
# @lc app=leetcode id=924 lang=python3
#
# [924] Minimize Malware Spread
#

# @lc code=start
class Union_Find:
    def __init__(self, n):
        self.n = n 
        self.parent = [i for i in range(n)]

    def find(self, x):
        if self.parent[x] == x:
            return x 
        else:
            self.parent[x] = self.find(self.parent[x])
            return self.parent[x]
    
    def union(self, x, y):
        x_root = self.find(x)
        y_root = self.find(y)
        self.parent[y_root] = x_root


class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        uf = Union_Find(n)
        for i in range(n):
            for j in range(n):
                if i != j and graph[i][j] == 1:
                    uf.union(i, j)

        initial = set(initial)
        connected = defaultdict(int)
        malware = defaultdict(list)
        for i in range(n):
            p = uf.find(i)
            connected[p] += 1
            if i in initial:
                malware[p].append(i)

        max_size = 0
        ret = None
        for ini in initial:
            p = uf.find(ini)
            if len(malware[p]) == 1:
                if connected[p] > max_size:
                    max_size = connected[p]
                    ret = ini
                elif connected[p] == max_size:
                    ret = min(ret, ini)
        
        if ret is None:
            return min(initial)
        else:
            return ret


# @lc code=end

